"use strict";
/*
 * Unless explicitly stated otherwise all files in this repository are licensed
 * under the Apache License Version 2.0.
 *
 * This product includes software developed at Datadog (https://www.datadoghq.com/).
 * Copyright 2021 Datadog, Inc.
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const layers = __importStar(require("./layers.json"));
const govLayers = __importStar(require("./layers-gov.json"));
const package_json_1 = require("../package.json");
const env_1 = require("./env");
const layer_1 = require("./layer");
const tracing_1 = require("./tracing");
const wrapper_1 = require("./wrapper");
const forwarder_1 = require("./forwarder");
const output_1 = require("./output");
const monitors_1 = require("./monitors");
const monitor_api_requests_1 = require("./monitor-api-requests");
var TagKeys;
(function (TagKeys) {
    TagKeys["Service"] = "service";
    TagKeys["Env"] = "env";
    TagKeys["Plugin"] = "dd_sls_plugin";
})(TagKeys || (TagKeys = {}));
module.exports = class ServerlessPlugin {
    constructor(serverless, _) {
        this.serverless = serverless;
        this.hooks = {
            "after:datadog:clean:init": this.afterPackageFunction.bind(this),
            "after:datadog:generate:init": this.beforePackageFunction.bind(this),
            "after:deploy:function:packageFunction": this.afterPackageFunction.bind(this),
            "after:package:createDeploymentArtifacts": this.afterPackageFunction.bind(this),
            "after:package:initialize": this.beforePackageFunction.bind(this),
            "before:deploy:function:packageFunction": this.beforePackageFunction.bind(this),
            "before:offline:start:init": this.beforePackageFunction.bind(this),
            "before:step-functions-offline:start": this.beforePackageFunction.bind(this),
            "after:deploy:deploy": this.afterDeploy.bind(this),
            "before:package:finalize": this.afterPackageFunction.bind(this),
        };
        this.commands = {
            datadog: {
                commands: {
                    clean: {
                        lifecycleEvents: ["init"],
                        usage: "Cleans up wrapper handler functions for DataDog, not necessary in most cases",
                    },
                    generate: {
                        lifecycleEvents: ["init"],
                        usage: "Generates wrapper handler functions for DataDog, not necessary in most cases",
                    },
                },
                lifecycleEvents: ["clean", "generate"],
                usage: "Automatically instruments your lambdas with DataDog",
            },
        };
    }
    beforePackageFunction() {
        return __awaiter(this, void 0, void 0, function* () {
            const config = env_1.getConfig(this.serverless.service);
            if (config.enabled === false)
                return;
            this.serverless.cli.log("Auto instrumenting functions with Datadog");
            validateConfiguration(config);
            const defaultRuntime = this.serverless.service.provider.runtime;
            const handlers = layer_1.findHandlers(this.serverless.service, config.exclude, defaultRuntime);
            env_1.setEnvConfiguration(config, handlers);
            const allLayers = { regions: Object.assign(Object.assign({}, layers.regions), govLayers.regions) };
            if (config.addLayers) {
                this.serverless.cli.log("Adding Lambda Library Layers to functions");
                this.debugLogHandlers(handlers);
                layer_1.applyLambdaLibraryLayers(this.serverless.service.provider.region, handlers, allLayers);
                if (env_1.hasWebpackPlugin(this.serverless.service)) {
                    env_1.forceExcludeDepsFromWebpack(this.serverless.service);
                }
            }
            else {
                this.serverless.cli.log("Skipping adding Lambda Library Layers, make sure you are packaging them yourself");
            }
            if (config.addExtension) {
                this.serverless.cli.log("Adding Datadog Lambda Extension Layer to functions");
                this.debugLogHandlers(handlers);
                layer_1.applyExtensionLayer(this.serverless.service.provider.region, handlers, allLayers);
            }
            else {
                this.serverless.cli.log("Skipping adding Lambda Extension Layer");
            }
            let tracingMode = tracing_1.TracingMode.NONE;
            if (config.enableXrayTracing && config.enableDDTracing) {
                tracingMode = tracing_1.TracingMode.HYBRID;
            }
            else if (config.enableDDTracing) {
                tracingMode = tracing_1.TracingMode.DD_TRACE;
            }
            else if (config.enableXrayTracing) {
                tracingMode = tracing_1.TracingMode.XRAY;
            }
            tracing_1.enableTracing(this.serverless.service, tracingMode, handlers);
        });
    }
    afterPackageFunction() {
        return __awaiter(this, void 0, void 0, function* () {
            const config = env_1.getConfig(this.serverless.service);
            if (config.enabled === false)
                return;
            // Create an object that contains some of our booleans for the forwarder
            const forwarderConfigs = {
                AddExtension: config.addExtension,
                IntegrationTesting: config.integrationTesting,
                SubToApiGatewayLogGroup: config.subscribeToApiGatewayLogs,
                SubToHttpApiLogGroup: config.subscribeToHttpApiLogs,
                SubToWebsocketLogGroup: config.subscribeToWebsocketLogs,
            };
            const defaultRuntime = this.serverless.service.provider.runtime;
            const handlers = layer_1.findHandlers(this.serverless.service, config.exclude, defaultRuntime);
            let datadogForwarderArn;
            datadogForwarderArn = setDatadogForwarder(config);
            if (datadogForwarderArn) {
                const aws = this.serverless.getProvider("aws");
                const errors = yield forwarder_1.addCloudWatchForwarderSubscriptions(this.serverless.service, aws, datadogForwarderArn, forwarderConfigs, handlers);
                for (const error of errors) {
                    this.serverless.cli.log(error);
                }
            }
            this.addTags(handlers, config.enableTags);
            wrapper_1.redirectHandlers(handlers, config.addLayers, config.customHandler);
            if (config.integrationTesting === false) {
                yield output_1.addOutputLinks(this.serverless, config.site, handlers);
            }
            else {
                this.serverless.cli.log("Skipped adding output links because 'integrationTesting' is set true");
            }
        });
    }
    afterDeploy() {
        return __awaiter(this, void 0, void 0, function* () {
            const config = env_1.getConfig(this.serverless.service);
            const service = this.serverless.service.getServiceName();
            const env = this.serverless.getProvider("aws").getStage();
            if (config.enabled === false)
                return;
            if (config.monitors && config.monitorsApiKey && config.monitorsAppKey) {
                const cloudFormationStackId = yield monitor_api_requests_1.getCloudFormationStackId(this.serverless);
                try {
                    const logStatements = yield monitors_1.setMonitors(config.site, config.monitors, config.monitorsApiKey, config.monitorsAppKey, cloudFormationStackId, service, env);
                    for (const logStatement of logStatements) {
                        this.serverless.cli.log(logStatement);
                    }
                }
                catch (err) {
                    this.serverless.cli.log("Error occurred when configuring monitors.");
                }
            }
            return output_1.printOutputs(this.serverless, config.site);
        });
    }
    debugLogHandlers(handlers) {
        for (const handler of handlers) {
            if (handler.type === layer_1.RuntimeType.UNSUPPORTED) {
                if (handler.runtime === undefined) {
                    this.serverless.cli.log(`Unable to determine runtime for function ${handler.name}`);
                }
                else {
                    this.serverless.cli.log(`Unable to add Lambda Layers to function ${handler.name} with runtime ${handler.runtime}`);
                }
            }
        }
    }
    /**
     * Check for service and env tags on provider level (under tags and stackTags),
     * as well as function level. Automatically create tags for service and env with
     * properties from deployment configurations if needed; does not override any existing values.
     */
    addTags(handlers, enableTags) {
        const provider = this.serverless.service.provider;
        this.serverless.cli.log(`Adding Plugin Version ${package_json_1.version} tag`);
        if (enableTags) {
            this.serverless.cli.log(`Adding service and environment tags`);
        }
        handlers.forEach(({ handler }) => {
            var _a, _b, _c, _d, _e, _f, _g;
            var _h, _j, _k, _l;
            (_a = handler.tags) !== null && _a !== void 0 ? _a : (handler.tags = {});
            handler.tags[TagKeys.Plugin] = `v${package_json_1.version}`;
            if (enableTags) {
                if (!((_b = provider.tags) === null || _b === void 0 ? void 0 : _b[TagKeys.Service]) && !((_c = provider.stackTags) === null || _c === void 0 ? void 0 : _c[TagKeys.Service])) {
                    (_d = (_h = handler.tags)[_j = TagKeys.Service]) !== null && _d !== void 0 ? _d : (_h[_j] = this.serverless.service.getServiceName());
                }
                if (!((_e = provider.tags) === null || _e === void 0 ? void 0 : _e[TagKeys.Env]) && !((_f = provider.stackTags) === null || _f === void 0 ? void 0 : _f[TagKeys.Env])) {
                    (_g = (_k = handler.tags)[_l = TagKeys.Env]) !== null && _g !== void 0 ? _g : (_k[_l] = this.serverless.getProvider("aws").getStage());
                }
            }
        });
    }
};
function validateConfiguration(config) {
    const siteList = ["datadoghq.com", "datadoghq.eu", "us3.datadoghq.com", "ddog-gov.com"];
    if (config.apiKey !== undefined && config.apiKMSKey !== undefined) {
        throw new Error("`apiKey` and `apiKMSKey` should not be set at the same time.");
    }
    if (config.site !== undefined && !siteList.includes(config.site.toLowerCase())) {
        throw new Error("Warning: Invalid site URL. Must be either datadoghq.com, datadoghq.eu, us3.datadoghq.com, or ddog-gov.com.");
    }
    if (config.addExtension) {
        if (config.apiKey === undefined && config.apiKMSKey === undefined) {
            throw new Error("When `addExtension` is true, `apiKey` or `apiKMSKey` must also be set.");
        }
    }
    if (config.monitors) {
        if (config.monitorsApiKey === undefined || config.monitorsAppKey === undefined) {
            throw new Error("When `monitors` is defined, `monitorsApiKey` and `monitorsAppKey` must also be defined");
        }
    }
}
function setDatadogForwarder(config) {
    const forwarderArn = config.forwarderArn;
    const forwarder = config.forwarder;
    if (forwarderArn && forwarder) {
        throw new Error("Both 'forwarderArn' and 'forwarder' parameters are set. Please only use the 'forwarderArn' parameter.");
    }
    else if (forwarderArn !== undefined && forwarder === undefined) {
        return forwarderArn;
    }
    else if (forwarder !== undefined && forwarderArn === undefined) {
        return forwarder;
    }
}
//# sourceMappingURL=index.js.map