"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isFunctionDefinitionHandler = exports.pushLayerARN = exports.applyExtensionLayer = exports.applyLambdaLibraryLayers = exports.findHandlers = exports.runtimeLookup = exports.RuntimeType = void 0;
const extensionLayerKey = "extension";
var RuntimeType;
(function (RuntimeType) {
    RuntimeType[RuntimeType["NODE"] = 0] = "NODE";
    RuntimeType[RuntimeType["PYTHON"] = 1] = "PYTHON";
    RuntimeType[RuntimeType["UNSUPPORTED"] = 2] = "UNSUPPORTED";
})(RuntimeType = exports.RuntimeType || (exports.RuntimeType = {}));
exports.runtimeLookup = {
    "nodejs10.x": RuntimeType.NODE,
    "nodejs12.x": RuntimeType.NODE,
    "nodejs14.x": RuntimeType.NODE,
    "python2.7": RuntimeType.PYTHON,
    "python3.6": RuntimeType.PYTHON,
    "python3.7": RuntimeType.PYTHON,
    "python3.8": RuntimeType.PYTHON,
    "python3.9": RuntimeType.PYTHON,
};
function findHandlers(service, exclude, defaultRuntime) {
    return Object.entries(service.functions)
        .map(([name, handler]) => {
        let { runtime } = handler;
        if (runtime === undefined) {
            runtime = defaultRuntime;
        }
        if (runtime !== undefined && runtime in exports.runtimeLookup) {
            return { type: exports.runtimeLookup[runtime], runtime, name, handler };
        }
        return { type: RuntimeType.UNSUPPORTED, runtime, name, handler };
    })
        .filter((result) => result !== undefined)
        .filter((result) => exclude === undefined || (exclude !== undefined && !exclude.includes(result.name)));
}
exports.findHandlers = findHandlers;
function applyLambdaLibraryLayers(region, handlers, layers) {
    const regionRuntimes = layers.regions[region];
    if (regionRuntimes === undefined) {
        return;
    }
    for (const handler of handlers) {
        if (handler.type === RuntimeType.UNSUPPORTED) {
            continue;
        }
        const { runtime } = handler;
        const lambdaLayerARN = runtime !== undefined ? regionRuntimes[runtime] : undefined;
        let currentLayers = getLayers(handler);
        if (lambdaLayerARN) {
            currentLayers = pushLayerARN([lambdaLayerARN], currentLayers);
            setLayers(handler, currentLayers);
        }
    }
}
exports.applyLambdaLibraryLayers = applyLambdaLibraryLayers;
function applyExtensionLayer(region, handlers, layers) {
    const regionRuntimes = layers.regions[region];
    if (regionRuntimes === undefined) {
        return;
    }
    for (const handler of handlers) {
        if (handler.type === RuntimeType.UNSUPPORTED) {
            continue;
        }
        let extensionLayerARN;
        extensionLayerARN = regionRuntimes[extensionLayerKey];
        let currentLayers = getLayers(handler);
        if (extensionLayerARN) {
            currentLayers = pushLayerARN([extensionLayerARN], currentLayers);
            setLayers(handler, currentLayers);
        }
    }
}
exports.applyExtensionLayer = applyExtensionLayer;
function pushLayerARN(layerARNs, currentLayers) {
    for (const layerARN of layerARNs) {
        if (!new Set(currentLayers).has(layerARN)) {
            currentLayers.push(layerARN);
        }
    }
    return currentLayers;
}
exports.pushLayerARN = pushLayerARN;
function isFunctionDefinitionHandler(funcDef) {
    return typeof funcDef.handler === "string";
}
exports.isFunctionDefinitionHandler = isFunctionDefinitionHandler;
function getLayers(handler) {
    const layersList = handler.handler.layers;
    if (layersList === undefined) {
        return [];
    }
    return layersList;
}
function setLayers(handler, layers) {
    handler.handler.layers = layers;
}
//# sourceMappingURL=layer.js.map